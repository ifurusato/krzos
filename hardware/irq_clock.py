#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# author:   Murray Altheim
# created:  2021-10-09
# modified: 2025-09-14
#
# Copyright 2020-2025 by Murray Altheim. All rights reserved. This file is part
# of the Robot Operating System project, released under the MIT License. Please
# see the LICENSE file included as part of this package.
#

import itertools
from datetime import datetime as dt
from colorama import init, Fore, Style
init()

from gpiozero import DigitalInputDevice

from core.logger import Logger, Level
from core.component import Component
from core.util import Util

class IrqClock(Component):
    '''
    Sets up a falling-edge interrupt on a GPIO pin, whose toggle (an Interrupt
    Request) is generated by an external source. When the interrupt is
    triggered any registered callbacks are executed.

    This is used predominantly for motor control timing.

    The callbacks are not executed asynchronously so any of them can block and
    throw off the clock timing. Hence callbacks should all return immediately.
    This class is ideally only used by a single subscriber/respondent.

    This uses gpiozero for edge detection.

    Make sure to call close() when finished to free up resources.

    :param config:     The application configuration.
    :param level:      the logging level.
    '''
    def __init__(self, config, level=Level.INFO):
        self._log = Logger('irq-clock', level)
        Component.__init__(self, self._log, suppressed=False, enabled=True)
        if config is None:
            raise ValueError('no configuration provided.')
        _cfg = config['kros'].get('hardware').get('irq_clock')
        self._initd         = False
        self._counter       = itertools.count()
        self.__callbacks    = []
        self.__lf_callbacks = []
        self._freq_divider  = _cfg.get('freq_divider')
        self._pin           = _cfg.get('pin')
        self._input         = None
        self._log.info('IRQ clock pin:\t{}'.format(self._pin))
        self._log.info('ready.')

    @property
    def name(self):
        return 'irq-clock'

    def enable(self):
        Component.enable(self)
        if self.enabled:
            if not self._initd:
                try:
                    self._log.info('initialising gpiozero DigitalInputDevice…')
                    # STM32 output is likely push-pull, so pull_up=False is correct
                    self._input = DigitalInputDevice(self._pin, pull_up=False)
                    self._input.when_deactivated = self._callback_method  # on falling edge
                    self._log.info('configured IRQ clock via gpiozero on pin {}.'.format(self._pin))
                except Exception as e:
                    self._log.error('unable to enable IRQ clock: {}'.format(e))
                    raise e
                finally:
                    self._initd = True
        else:
            self._log.warning('unable to enable IRQ clock.')

    def add_callback(self, callback):
        '''
        Adds a callback to those triggered by clock ticks.
        '''
        if not callable(callback):
            raise Exception('callback argument is not a function.')
        if callback:
            if callback in self.__callbacks:
                raise Exception('callback already exists.')
            self._log.info('added callback: {}.{}()'.format(Util.get_class_name_of_method(callback), callback.__name__))
            self.__callbacks.append(callback)
        else:
            raise TypeError('null callback argument')

    def add_low_frequency_callback(self, callback):
        '''
        Adds a callback to those triggered by clock ticks, called at a
        lower frequency than the regular callbacks.
        '''
        if not callable(callback):
            raise Exception('callback argument is not a function.')
        if callback:
            if callback in self.__lf_callbacks:
                raise Exception('callback already exists.')
            self.__lf_callbacks.append(callback)
        else:
            raise TypeError('null callback argument')

    def remove_callback(self, callback):
        '''
        Removes a callback from the internal list.
        '''
        if callback:
            if callback in self.__callbacks:
                self.__callbacks.remove(callback)
        else:
            raise TypeError('null callback argument')

    def _callback_method(self):
        if self.enabled:
            for callback in self.__callbacks:
                callback()
            if next(self._counter) % self._freq_divider == 0:
                for lf_callback in self.__lf_callbacks:
                    lf_callback()

    def close(self):
        try:
            self._log.info('closing IRQ clock…')
            if self._input:
                self._input.close()
            self._log.info('IRQ clock closed.')
        except Exception as e:
            self._log.error('error closing gpiozero Button: {}'.format(e))
        Component.close(self)
        self._log.info('closed.')

#EOF
